"""Pseudo code indicating how the module should be restructured
in a more clear and concise way

LEARN FROM: https://doc.qt.io/qt-5/threads-technologies.html#example-use-cases
"""

class QDeviceIO(QtCore.QObject):
    XXX DON'T
        def __init__(device):
            Note: 'device' is now an argument to __init__, instead of having
            to call another method 'attach_device' immediatly after __init__
        
        def attach_device(...)
            Obsolete, because 'device' is now an argument to __init__
    \XXX BECAUSE class QDeviceIO will be mixed into parent classes that
    take different kinds of 'device's. It is handier to keep attach_device()
        

    def create_worker_DAQ():
        XXX DONT'T
            Not just create the worker, but also start the event loop immediately
            Embed the method worker_DAQ.start_thread_worker_DAQ(...) into this
            All DAQ_trigger modes should start-up in the idle/suspended/waiting state
            Only after the user gives worker_DAQ.start should running be set to True
            and should the acquisition, hence, start.
            
            For mode INTERNAL TIMER, also create the QTimer here, instead of
            inside method worker_DAQ.run(). But mind: do not Qtimer.start() yet.
            Also, INTERNAL TIMER probably does not need statement: self.thread_DAQ.started.connect(self.worker_DAQ.run)
        XXX BECAUSE the Qtimer must be created inside the worker thread method '_do_work' !!!
        XXX INSTEAD, keep as is
        
    def start_thread_worker_DAQ():
        keep as is
        
    class Worker_DAQ()
        def run()
            Should be renamed into '_do_work'
            Do not allow it to start twice, i.e. 'restart'. This might not
            be possible, because once the thread has finished (by calling
            our method stop which sets self.running = False) it might get
            garbage collected, maybe?
            
            XXX DON'T
                self.running = True  # NEW! Crucial!
            XXX
            
            # if INTERNAL TIMER
                create QTimer
                self.timer.start()
            
            # if EXTERNAL WAKE UP (aka SINGLE_SHOT_WAKE_UP)
                while self.running:
                    locker_wait = QtCore.QMutexLocker(self.mutex_wait)

                    if self.DEBUG:
                        dprint("Worker_DAQ  %s: waiting for trigger" %
                               self.dev.name, self.DEBUG_color)

                    self.qwc.wait(self.mutex_wait)
                    self.update()

                    locker_wait.unlock()
            
                if self.DEBUG:
                    dprint("Worker_DAQ  %s: done running" % self.dev.name,
                           self.DEBUG_color)
                       
            # if CONTINUOUS
                while self.running:
                    if self.suspend:        # if self.pause
                        if (self.suspend != self.suspended):        # if (self.pause != self.is_paused):
                            if self.DEBUG:
                                dprint("Worker_DAQ  %s: suspended" % 
                                       self.dev.name, self.DEBUG_color)
                            self.outer.signal_DAQ_suspended.emit()
                        
                        self.suspended = True
                        Time.sleep(0.01)  # Do not hog the CPU while suspended
                        pass
                    else:
                        self.suspended = False
                        self.update()
        
        def schedule_suspend(state)
            Perhaps rename schedule_pause() and schedule_resume()
            
    
        def stop()
            This is also /the end/ of the qthread. No restarting allowed anymore!
            
            # if INTERNAL TIMER
                self.timer.stop()
            
            # if EXTERNAL WAKE UP (aka SINGLE_SHOT_WAKE_UP)
            # or if CONTINUOUS
                self.running = false
            
            